package com.gplanet.commerce.security;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.when;
import static org.springframework.security.test.web.servlet.setup.SecurityMockMvcConfigurers.springSecurity;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.header;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.redirectedUrl;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Optional;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.bean.override.mockito.MockitoBean;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.web.context.WebApplicationContext;

import com.gplanet.commerce.entities.Usuario;
import com.gplanet.commerce.repositories.UsuarioRepository;
import com.gplanet.commerce.services.UsuarioService;

@SpringBootTest
@AutoConfigureMockMvc
@ActiveProfiles("test")
public class SecurityVulnerabilityTest {

    @Autowired
    private WebApplicationContext context;

    private MockMvc mockMvc;

    @MockitoBean
    private UsuarioRepository usuarioRepository;
    
    @MockitoBean
    private UsuarioDetallesService usuarioDetallesService;

    @MockitoBean
    private UsuarioService usuarioService;

    @BeforeEach
    public void setup() {
        mockMvc = MockMvcBuilders
                .webAppContextSetup(context)
                .apply(springSecurity())
                .build();
        
        // Set up a test user
        Usuario testUser = new Usuario();
        testUser.setEmail("user@example.com");
        testUser.setPassword("$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG"); // "password" encoded
        testUser.setNombre("Test User");
        testUser.setRol(Usuario.Role.USER);
        
        when(usuarioRepository.findByEmail("user@example.com")).thenReturn(Optional.of(testUser));
        when(usuarioService.buscarPorEmail(anyString())).thenReturn(testUser);
        
        // Mock UserDetailsService to return proper UserDetails objects
        Collection<GrantedAuthority> userAuthorities = new ArrayList<>();
        userAuthorities.add(new SimpleGrantedAuthority("ROLE_USER"));
        UsuarioDetalles userDetails = new UsuarioDetalles(testUser, userAuthorities);
        
        when(usuarioDetallesService.loadUserByUsername("user@example.com")).thenReturn(userDetails);
    }

    @Test
    public void testSecurityHeaders() throws Exception {
        mockMvc.perform(get("/"))
                .andExpect(result -> {
                    // Check for either CSP header or X-XSS-Protection
                    String cspHeader = result.getResponse().getHeader("Content-Security-Policy");
                    String xssHeader = result.getResponse().getHeader("X-XSS-Protection");
                    
                    if (cspHeader != null) {
                        // Modern approach - using CSP
                        assertTrue(cspHeader.length() > 0, "Content-Security-Policy header should be present");
                    } else if ("0".equals(xssHeader)) {
                        // Spring Security might set this to 0 in modern configurations
                        // which is valid as they prefer to use CSP instead
                        assertTrue(true);
                    } else if (xssHeader != null) {
                        // Traditional approach
                        assertEquals("1; mode=block", xssHeader);
                    } else {
                        fail("Neither Content-Security-Policy nor X-XSS-Protection header found");
                    }
                });
    }

    @Test
    public void testContentTypeOptions() throws Exception {
        mockMvc.perform(get("/"))
                .andExpect(header().string("X-Content-Type-Options", "nosniff"));
    }

    @Test
    public void testFrameOptions() throws Exception {
        mockMvc.perform(get("/"))
                .andExpect(header().string("X-Frame-Options", "DENY"));
    }

    @Test
    public void testCsrfProtection_Post() throws Exception {

        // Should fail without CSRF token
        mockMvc.perform(post("/usuarios/perfil")
                .contentType(MediaType.APPLICATION_FORM_URLENCODED)
                .param("nombre", "Test User")
                .param("email", "user@example.com"))
                .andExpect(status().isForbidden());

        // Should pass with CSRF token
        mockMvc.perform(post("/usuarios/perfil")
                .with(SecurityMockMvcRequestPostProcessors.csrf())
                .contentType(MediaType.APPLICATION_FORM_URLENCODED)
                .param("nombre", "Test User")
                .param("email", "user@example.com"))
                .andExpect(status().is3xxRedirection())
                .andExpect(redirectedUrl("**/usuarios/login")); 
    }
}